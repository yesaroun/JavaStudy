/*=======================================
    ■■■ 정렬(Sort) 알고리즘 ■■■
=======================================*/

// 향상된 버블 정렬(Bubble Sort)

// ※ 앞에서 본 Selection Sort(Test109) 나 Bubble Sort(Test110) 의 성능은 같다
//		(→ 반복의 횟수로 추정)
//		하지만, 향상된 Bubble Sort는 대상 데이터의 구조에 따라서
//		일반 Bubble Sort나 Selection Sort보다 성능이 좋을 수 있다.

// 원본 데이터 : 61 15 20 22 30
//				 15 20 22 30 61  - 1회전 (스왑(자리 바꿈) 발생 → true) → 다음 회전 진행 ○
//				 15 20 22 30 61	 - 2회전 (스왑 발생 → false) → 다음 회전 진행 X

//==> 1회전 수행... 2회전 수행... 을 해보았더니...
//	  2회전에서 스왑(자리바꿈)이 전혀 일어나지 않았기 때문에
//	  불필요한 추가 연산(더 이상의 회전)은 무의미한 것으로 판단하여
//	  수행하지 않는다.

// 실행 예)
// Source Data : 10 50 20 30 40
// Sorted Data : 10 20 30 40 50

//check Test1111
// 나머지 정렬 알고리즘 찾아서 구현하기


public class Test111
{
	public static void main(String[] args)
	{
		int[] a = {10, 50, 20, 30, 40};
		/*
		10 50 20 30 40
		== --
		10 20 50 30 40
		   == --
		10 20 30 50 40
			  == --
		10 20 30 40 50
				 == --
		--------------------------------------- 1회전 → 스왑 발생

		10 20 30 40 50
		== --
		10 20 30 40 50
		   == --
		10 20 30 40 50
			  == --
		--------------------------------------- 2회전 → 스왑 발생하지 않음
			
			Ⅹ
			Ⅹ
		--------------------------------------- 3회전 → Ⅹ

			Ⅹ
		--------------------------------------- 4회전 → Ⅹ
		*/

		System.out.print("Source Data : ");
		for(int n : a)
		{
			System.out.printf("%d ", n);
		}
		System.out.println();
		

		for(int i=1; i<a.length; i++)
		{	
			int check = 0;
			for(int j=0; j<a.length-1; j++)
			{
				if(a[j]>a[j+1])
				{
					a[j] = a[j]^a[j+1];
					a[j+1] = a[j+1]^a[j];
					a[j] = a[j]^a[j+1];
					check++;
				}
			}
			if (check == 0)
			{
				break;
			}			
		}
	

		System.out.print("Sorted Data : ");
		for(int n : a)
		{
			System.out.printf("%d ", n);
		}
		System.out.println();

	}
}